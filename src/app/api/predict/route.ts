import { NextRequest, NextResponse } from "next/server";
import { getHistoricalRates, getLatestRate } from "@/lib/frankfurter";
import type { PredictionResponse } from "@/types";

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { source_currency, target_currency, amount } = body;

    if (!source_currency || !target_currency || !amount) {
      return NextResponse.json(
        { error: "source_currency, target_currency, and amount are required" },
        { status: 400 }
      );
    }

    // Fetch current rate
    const { rate: currentRate } = await getLatestRate(
      source_currency,
      target_currency
    );

    // Fetch last 90 days of historical data
    const endDate = new Date().toISOString().split("T")[0];
    const startDate = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000)
      .toISOString()
      .split("T")[0];

    const historicalRates = await getHistoricalRates(
      source_currency,
      target_currency,
      startDate,
      endDate
    );

    // Try ML service first
    const mlServiceUrl =
      process.env.ML_SERVICE_URL || "http://localhost:8000";

    try {
      const mlResponse = await fetch(`${mlServiceUrl}/predict`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          from_currency: source_currency,
          to_currency: target_currency,
        }),
        signal: AbortSignal.timeout(5000),
      });

      if (mlResponse.ok) {
        const mlData = await mlResponse.json();

        const prediction: PredictionResponse = {
          current_rate: currentRate,
          predicted_rate_24h: mlData.predicted_rate_24h ?? currentRate,
          predicted_rate_72h: mlData.predicted_rate_72h ?? currentRate,
          confidence: mlData.confidence ?? 0.8,
          recommendation: mlData.recommendation ?? "NEUTRAL",
          potential_savings: mlData.potential_savings ?? "0.00",
          reasoning:
            mlData.reasoning ??
            "Prediction generated by ML model.",
          historical_rates: historicalRates,
          predicted_rates: mlData.predicted_rates ?? [],
        };

        return NextResponse.json(prediction);
      }

      // ML service returned non-OK, fall through to fallback
    } catch {
      // ML service unavailable, use fallback
    }

    // FALLBACK: Statistical analysis from historical data
    const rates = historicalRates.map((r) => r.rate);

    // Calculate 7-day moving average
    const last7 = rates.slice(-7);
    const avg7d =
      last7.length > 0
        ? last7.reduce((sum, r) => sum + r, 0) / last7.length
        : currentRate;

    // Calculate 30-day moving average
    const last30 = rates.slice(-30);
    const avg30d =
      last30.length > 0
        ? last30.reduce((sum, r) => sum + r, 0) / last30.length
        : currentRate;

    // Determine recommendation
    let recommendation: "SEND_NOW" | "WAIT" | "NEUTRAL";
    let reasoning: string;

    if (currentRate > avg30d * 1.003) {
      recommendation = "SEND_NOW";
      reasoning = `The current rate (${currentRate.toFixed(4)}) is above the 30-day average (${avg30d.toFixed(4)}) by more than 0.3%. This is a favorable rate — sending now could save you money compared to waiting.`;
    } else if (currentRate < avg30d * 0.997) {
      recommendation = "WAIT";
      reasoning = `The current rate (${currentRate.toFixed(4)}) is below the 30-day average (${avg30d.toFixed(4)}) by more than 0.3%. The rate may improve — consider waiting for a better opportunity.`;
    } else {
      recommendation = "NEUTRAL";
      reasoning = `The current rate (${currentRate.toFixed(4)}) is close to the 30-day average (${avg30d.toFixed(4)}). There is no strong signal to send now or wait.`;
    }

    // Predicted rate is the 7-day moving average
    const predictedRate24h = avg7d;

    // Generate predicted rates for the next 3 days based on trend
    const trend = avg7d - avg30d;
    const today = new Date();
    const predictedRates = [1, 2, 3].map((daysAhead) => {
      const futureDate = new Date(today);
      futureDate.setDate(futureDate.getDate() + daysAhead);
      return {
        date: futureDate.toISOString().split("T")[0],
        rate: Number((avg7d + trend * daysAhead * 0.1).toFixed(4)),
      };
    });

    // Calculate potential savings
    const rateDiff = Math.abs(currentRate - avg30d);
    const potentialSavings = (rateDiff * Number(amount)).toFixed(2);

    const prediction: PredictionResponse = {
      current_rate: currentRate,
      predicted_rate_24h: Number(predictedRate24h.toFixed(4)),
      predicted_rate_72h: Number(predictedRates[2]?.rate ?? predictedRate24h),
      confidence: 0.6,
      recommendation,
      potential_savings: `${potentialSavings} ${target_currency}`,
      reasoning,
      historical_rates: historicalRates,
      predicted_rates: predictedRates,
    };

    return NextResponse.json(prediction);
  } catch (error) {
    const message =
      error instanceof Error ? error.message : "Unknown error";
    return NextResponse.json(
      { error: `Prediction failed: ${message}` },
      { status: 500 }
    );
  }
}
